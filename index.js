require("dotenv").config(); // Carrega as vari√°veis de ambiente do arquivo .env
const {
  default: makeWASocket,
  useMultiFileAuthState,
  DisconnectReason,
} = require("@whiskeysockets/baileys");
const { exec } = require("child_process");
const { buscarImagem } = require("./unsplash");
const axios = require("axios");
const FormData = require("form-data");
const math = require("mathjs"); // Importando a biblioteca mathjs
const translate = require("@vitalets/google-translate-api");
const fs = require("fs");
const PREFIX = "!";
const SIMI_API_URL = "https://api.simsimi.vn/v1/simtalk"; // URL da API SimSimi

// Obtendo o n√∫mero de telefone do dono do arquivo .env
const OWNER_PHONE_NUMBER = process.env.OWNER_PHONE_NUMBER;

let botStartTime = Date.now(); // Timestamp inicial para uptime

async function startBot() {
  const { state, saveCreds } = await useMultiFileAuthState("auth_info");
  const sock = makeWASocket({
    auth: state,
    printQRInTerminal: true,
    //logger: console,
  });

  sock.ev.on("creds.update", saveCreds);

  sock.ev.on("connection.update", (update) => {
    const { connection, lastDisconnect } = update;
    if (connection === "close") {
      const shouldReconnect =
        lastDisconnect.error?.output?.statusCode !== DisconnectReason.loggedOut;
      console.log(
        "Connection closed due to ",
        lastDisconnect.error,
        ", reconnecting ",
        shouldReconnect
      );
      if (shouldReconnect) {
        startBot();
      }
    } else if (connection === "open") {
      console.log("Opened connection");
    }
  });

  sock.ev.on("messages.upsert", async ({ messages }) => {
    const msg = messages[0];
    if (!msg.message || msg.key.fromMe) return;

    const text =
      msg.message.conversation || msg.message.extendedTextMessage?.text;
    if (!text || !text.startsWith(PREFIX)) return;

    const command = normalizeCommand(
      text.slice(PREFIX.length).trim().toLowerCase()
    );
    const timestampSent = Date.now(); // Timestamp do envio da mensagem

    // Fun√ß√£o para verificar se o usu√°rio √© o dono
    const isOwner = msg.key.remoteJid === OWNER_PHONE_NUMBER;

    const messageContent =
      msg.message.conversation || msg.message.extendedTextMessage?.text || "";
    // const command = messageContent.split(" ")[0].toLowerCase().substring(1);
    const args = messageContent.split(" ").slice(1);

    // Verifica se o bot √© administrador
    const isAdmin = msg.key.participant ? true : false; // Adapte isso conforme necess√°rio

    // Fun√ß√£o para gerar uma resposta criativa com base na lat√™ncia
    function getPingResponse(latency) {
      if (latency < 50) {
        return `*Estou mais r√°pido que um raio* ‚ö°\n*Tempo de resposta*: ${latency}ms`;
      } else if (latency < 150) {
        return `*Hoje eu t√¥ cansado* üò¥\n*Tempo de resposta*: ${latency}ms`;
      } else {
        return `*Estou dormindo* üí§\n*Tempo de resposta*: ${latency}ms`;
      }
    }

    // Comando de ping
    if (command === "ping") {
      // Verifica se o timestamp da mensagem existe e est√° em segundos ou milissegundos
      const timestamp = msg.messageTimestamp
        ? typeof msg.messageTimestamp === "number"
          ? msg.messageTimestamp * 1000
          : Date.now()
        : Date.now();

      const ms = Date.now() / timestamp; // Calcula a lat√™ncia (tempo de resposta)

      // Verifica se o c√°lculo da lat√™ncia resultou em NaN, atribuindo 0ms como fallback
      const validLatency = isNaN(ms) ? 0 : ms;

      // Arredonda a lat√™ncia para um n√∫mero inteiro
      const roundedLatency = validLatency.toFixed(0);

      // Gera a resposta com base na lat√™ncia v√°lida
      const responseMsg = `*Pong!* üèì\n\n${getPingResponse(
        roundedLatency
      )}\n\n${getMessageEnd()}`;

      // Envia a mensagem com o tempo de resposta
      await sock.sendMessage(msg.key.remoteJid, { text: responseMsg });

      // Reage √† mensagem
      await sock.sendMessage(msg.key.remoteJid, {
        react: { text: "üèì", key: msg.key },
      });

      return;
    }

    // Fun√ß√£o para carregar a lista de comandos do arquivo JSON
    function loadCommands() {
      const data = fs.readFileSync("comandos.json", "utf-8");
      return JSON.parse(data);
    }

    // Fun√ß√£o para verificar se o comando existe no JSON
    function commandExists(command, commandsList) {
      return commandsList.hasOwnProperty(command);
    }

    // Carrega a lista de comandos ao iniciar
    const commandsList = loadCommands();

    // Supondo que 'command' seja o comando que o usu√°rio enviou
    if (command) {
      if (commandExists(command, commandsList)) {
        // O comando existe no .json, aqui executa o que precisa
        console.log(`Comando ${command} encontrado no .json.`);
      } else {
        // O comando n√£o existe, reage com ponto de interroga√ß√£o
        const responseMsg = `O comando *${command}* n√£o existe. Use *!menu* para ver os comandos dispon√≠veis.`;

        await sock.sendMessage(msg.key.remoteJid, { text: responseMsg });
        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "‚ùì", key: msg.key },
        });
      }
    }

    // Comando de c√°lculo usando mathjs
    if (command.startsWith("calcular")) {
      const expression = text.slice(PREFIX.length + 9).trim(); // Remove PREFIX e 'calcular'

      try {
        const result = math.evaluate(expression);
        await sock.sendMessage(msg.key.remoteJid, {
          text: `*Resultado:* ${result}\n\n${getMessageEnd()}`,
        });
        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "üìä", key: msg.key }, // Rea√ß√£o para c√°lculo
        });
      } catch (error) {
        await sock.sendMessage(msg.key.remoteJid, {
          text: `*Erro ao calcular a express√£o:* ${
            error.message
          }\n\n${getMessageEnd()}`,
        });
        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro para c√°lculo
        });
      }
      return;
    }

    // Comando para abrir aplicativos no Windows (restrito ao dono)
    if (command.startsWith("app")) {
      if (!isOwner) {
        await sock.sendMessage(msg.key.remoteJid, {
          text:
            "*Voc√™ n√£o tem permiss√£o para usar este comando.*\n\n" +
            getMessageEnd(),
        });
        return;
      }
      const app = command.split(" ")[1];
      exec(app, (err) => {
        if (err) {
          sock.sendMessage(msg.key.remoteJid, {
            text: `*Erro ao abrir ${app}:* ${
              err.message
            }\n\n${getMessageEnd()}`,
          });
          sock.sendMessage(msg.key.remoteJid, {
            react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro para abrir aplicativo
          });
        } else {
          sock.sendMessage(msg.key.remoteJid, {
            text: `${app} *foi aberto com sucesso!* üéâ\n\n${getMessageEnd()}`,
          });
          sock.sendMessage(msg.key.remoteJid, {
            react: { text: "‚úÖ", key: msg.key }, // Rea√ß√£o de sucesso para abrir aplicativo
          });
        }
      });
      return;
    }

    // Comando de criador
    if (command === "criador") {
      await sock.sendMessage(msg.key.remoteJid, {
        text:
          "Eu sou um bot criado por *Pedro Henrique*, vulgo *Caquinho Dev*. üë®‚Äçüíª\n\n" +
          getMessageEnd(),
      });
      await sock.sendMessage(msg.key.remoteJid, {
        react: { text: "üë®‚Äçüíª", key: msg.key },
      });
      return;
    }

    // Comando de menu
    if (command === "menu") {
      const menu = `‡ºíWÃ∑EÃ∑LÃ∑CÃ∑OÃ∑MÃ∑EÃ∑‡ºí
      „Äé ùêåùêÑùêçùêî „Äè
    ‚ï≠‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïØ
    | ‡≥à·çùÕ°Õúü§ë !calcular
    | ‡≥à·çùÕ°Õúü§ë !simi 
    | ‡≥à·çùÕ°Õúü§ë !desligar (dono)
    | ‡≥à·çùÕ°Õúü§ë !reinciar (dono)
    | ‡≥à·çùÕ°Õúü§ë !app (dono)
    | ‡≥à·çùÕ°Õúü§ë !uptime
    | ‡≥à·çùÕ°Õúü§ë !ping
    | ‡≥à·çùÕ°Õúü§ë !dono
    | ‡≥à·çùÕ°Õúü§ë !criador
    | ‡≥à·çùÕ°Õúü§ë !info
    | ‡≥à·çùÕ°Õúü§ë !fechar (admin)
    | ‡≥à·çùÕ°Õúü§ë !abrir (admin)
    | ‡≥à·çùÕ°Õúü§ë !menu
    | ‡≥à·çùÕ°Õúü§ë !imagem
    | ‡≥à·çùÕ°Õúü§ë !dado
    | ‡≥à·çùÕ°Õúü§ë !moeda
    | ‡≥à·çùÕ°Õúü§ë !adivinha
    ‚ï∞‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïÆ
      `;
      await sock.sendMessage(msg.key.remoteJid, {
        text: menu + `\n\n${getMessageEnd()}`,
      });
      await sock.sendMessage(msg.key.remoteJid, {
        react: { text: "üìú", key: msg.key },
      });
      return;
    }

    // Comando de dono
    if (command === "dono") {
      await sock.sendMessage(msg.key.remoteJid, {
        text: "O dono do bot √© *Pedro Henrique*. üëë\n\n" + getMessageEnd(),
      });
      await sock.sendMessage(msg.key.remoteJid, {
        react: { text: "üëë", key: msg.key },
      });
      return;
    }

    // Comando de info
    if (command === "info") {
      await sock.sendMessage(msg.key.remoteJid, {
        text: `Informa√ß√µes sobre o bot ü§ñ:\n\n- *Bot: MagoBot*\n- *Vers√£o: 1.2*\n- *Criador: Pedro Henrique üßë‚Äçüíª*\n\n${getMessageEnd()}`,
      });
      await sock.sendMessage(msg.key.remoteJid, {
        react: { text: "‚ÑπÔ∏è", key: msg.key },
      });
      return;
    }

    // Comando para desligar o computador (restrito ao dono)
    if (command === "desligar") {
      if (!isOwner) {
        await sock.sendMessage(msg.key.remoteJid, {
          text:
            "*Voc√™ n√£o tem permiss√£o para usar este comando.*\n\n" +
            getMessageEnd(),
        });
        return;
      }
      exec("shutdown /s /f /t 0", (err) => {
        if (err) {
          sock.sendMessage(msg.key.remoteJid, {
            text: `*Erro ao desligar o computador:* ${
              err.message
            }\n\n${getMessageEnd()}`,
          });
          sock.sendMessage(msg.key.remoteJid, {
            react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro para desligar
          });
        } else {
          sock.sendMessage(msg.key.remoteJid, {
            text: "*Computador ser√° desligado!* üíªüîå\n\n" + getMessageEnd(),
          });
          sock.sendMessage(msg.key.remoteJid, {
            react: { text: "üîã", key: msg.key }, // Rea√ß√£o para desligar
          });
        }
      });
      return;
    }

    // Comando para reiniciar o computador (restrito ao dono)
    if (command === "reiniciar") {
      if (!isOwner) {
        await sock.sendMessage(msg.key.remoteJid, {
          text:
            "*Voc√™ n√£o tem permiss√£o para usar este comando.*\n\n" +
            getMessageEnd(),
        });
        return;
      }
      exec("shutdown /r /f /t 0", (err) => {
        if (err) {
          sock.sendMessage(msg.key.remoteJid, {
            text: `*Erro ao reiniciar o computador:* ${
              err.message
            }\n\n${getMessageEnd()}`,
          });
          sock.sendMessage(msg.key.remoteJid, {
            react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro para reiniciar
          });
        } else {
          sock.sendMessage(msg.key.remoteJid, {
            text: "*Computador ser√° reiniciado!* üîÑ\n\n" + getMessageEnd(),
          });
          sock.sendMessage(msg.key.remoteJid, {
            react: { text: "üîÑ", key: msg.key }, // Rea√ß√£o para reiniciar
          });
        }
      });
      return;
    }

    if (command === "dado") {
      const diceRoll = Math.floor(Math.random() * 6) + 1;
      await sock.sendMessage(msg.key.remoteJid, {
        text: `üé≤ Voc√™ rolou um *${diceRoll}*!\n\n${getMessageEnd()}`,
      });
    }

    if (command === "moeda") {
      // Gera um n√∫mero aleat√≥rio entre 0 e 1
      const result = Math.random() < 0.5 ? "cara" : "coroa";

      await sock.sendMessage(msg.key.remoteJid, {
        text: `ü™ô A moeda caiu em... *${result}*!\n\n${getMessageEnd()}`,
      });
    }

    if (command === "adivinha") {
      // Define o intervalo de n√∫meros para adivinhar
      const min = 1;
      const max = 100;
      sock.sendMessage(msg.key.remoteJid, {
        react: { text: "ü§î", key: msg.key }, // Rea√ß√£o para reiniciar
      });

      // O bot escolhe um n√∫mero aleat√≥rio dentro do intervalo
      const guessedNumber = Math.floor(Math.random() * (max - min + 1)) + min;

      await sock.sendMessage(msg.key.remoteJid, {
        text: `ü§î Estou pensando no n√∫mero... Ser√° que √© *${guessedNumber}*?\n\n${getMessageEnd()}`,
      });
    }

    //const { buscarImagem } = require("./unsplash"); // Importa a fun√ß√£o do arquivo unsplash.js

    // Adicione isso ao seu comando de !imagem
    if (command.startsWith("imagem")) {
      const keyword = text.slice(PREFIX.length + 7).trim(); // Remove PREFIX e 'imagem'

      if (!keyword) {
        await sock.sendMessage(msg.key.remoteJid, {
          text: `*Por favor, forne√ßa uma palavra-chave para a busca de imagem.*\n\n${getMessageEnd()}`,
        });
        return;
      }

      try {
        const imageBuffer = await buscarImagem(keyword);

        // Salve o buffer da imagem em um arquivo tempor√°rio
        const tempFilePath = `./temp_image_${Date.now()}.jpg`;
        const fs = require("fs");
        fs.writeFileSync(tempFilePath, imageBuffer);

        // Envie a imagem como m√≠dia
        await sock.sendMessage(msg.key.remoteJid, {
          image: { url: tempFilePath },
          caption: `Imagem relacionada a "${keyword}"\n\n${getMessageEnd()}`,
        });

        // Remove o arquivo tempor√°rio ap√≥s o envio
        fs.unlinkSync(tempFilePath);

        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "üñºÔ∏è", key: msg.key }, // Rea√ß√£o para imagem
        });
      } catch (error) {
        await sock.sendMessage(msg.key.remoteJid, {
          text: `*Erro ao buscar a imagem:* ${
            error.message
          }\n\n${getMessageEnd()}`,
        });
        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro para imagem
        });
      }
      return;
    }

    // Fun√ß√£o para fazer a requisi√ß√£o √† API do SimSimi
    async function getSimSimiResponse(query) {
      let data = new FormData();
      data.append("lc", "pt");
      data.append("key", ""); // Substitua esse vazio pela sua chave da API SimSimi se necess√°rio
      data.append("text", query);

      let config = {
        method: "post",
        url: "https://api.simsimi.vn/v1/simtalk",
        headers: {
          ...data.getHeaders(),
        },
        data: data,
      };

      try {
        const response = await axios.request(config);

        // Verifica se o status √© diferente de 200
        if (response.status !== 200) {
          console.error("Error:", response.statusText);
          return "Desculpe, n√£o consegui entender sua mensagem."; // Mensagem padr√£o para status n√£o 200
        }

        // Verifica se a resposta cont√©m a mensagem
        if (
          response.data &&
          response.data.message &&
          response.data.message !== ""
        ) {
          return response.data.message;
        } else {
          console.error("Error: No valid response message found.");
          return "Desculpe, n√£o consegui entender sua mensagem."; // Mensagem padr√£o caso n√£o encontre uma resposta v√°lida
        }
      } catch (error) {
        // Verifica se o erro cont√©m uma resposta com uma mensagem
        if (
          error.response &&
          error.response.data &&
          error.response.data.message
        ) {
          console.log(JSON.stringify(error.response.data)); // Exibir a resposta de erro completa da API
          return error.response.data.message;
        }

        console.error("Error:", error);
        return "Desculpe, houve um erro ao processar sua mensagem."; // Mensagem padr√£o para outros erros
      }
    }

    // Comando SimSimi
    if (command.startsWith("simi")) {
      const message = text.slice(PREFIX.length + 4).trim();
      if (!message) {
        await sock.sendMessage(msg.key.remoteJid, {
          text: `*Por favor, forne√ßa uma mensagem para o SimSimi.*\n\n${getMessageEnd()}`,
        });
        return;
      }

      try {
        const responseText = await getSimSimiResponse(message);

        await sock.sendMessage(msg.key.remoteJid, {
          text: responseText + `\n\n${getMessageEnd()}`,
        });
        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "üê•", key: msg.key }, // Rea√ß√£o para SimSimi
        });
      } catch (error) {
        await sock.sendMessage(msg.key.remoteJid, {
          text: `*Erro ao se comunicar com a API SimSimi:* ${
            error.message
          }\n\n${getMessageEnd()}`,
        });
        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro para SimSimi
        });
      }
    }

    // Comando de abrir grupo
    if (command === "abrir") {
      if (!isOwner) {
        await sock.sendMessage(msg.key.remoteJid, {
          text:
            "*Voc√™ n√£o tem permiss√£o para usar este comando.*\n\n" +
            getMessageEnd(),
        });
        return;
      }

      const botAdmin = await isBotAdmin(msg.key.remoteJid);
      if (!botAdmin) {
        await sock.sendMessage(msg.key.remoteJid, {
          text:
            "*N√£o posso abrir o grupo porque n√£o sou administrador.*\n\n" +
            getMessageEnd(),
        });
        await sock.sendMessage(msg.key.remoteJid, {
          react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro
        });
        return;
      }

      // Abre o grupo
      await sock.groupSettingUpdate(msg.key.remoteJid, "not_announcement");
      await sock.sendMessage(msg.key.remoteJid, {
        text: "*O grupo foi aberto!* üîì\n\n" + getMessageEnd(),
      });
      return;
    }

    if (command === "regras") {
      const groupMetadata = await sock.groupMetadata(msg.key.remoteJid);
      const groupDescription =
        groupMetadata.desc || "Nenhuma descri√ß√£o dispon√≠vel.";

      await sock.sendMessage(msg.key.remoteJid, {
        text: `üìú *Regras do Grupo:*\n\n${groupDescription}\n\n${getMessageEnd()}`,
      });
    }

    // Comando de uptime
    if (command === "uptime") {
      const uptime = formatUptime(Date.now() - botStartTime);
      await sock.sendMessage(msg.key.remoteJid, {
        text: `üïê O bot est√° online h√° *${uptime}*.\n\n${getMessageEnd()}`,
      });
      await sock.sendMessage(msg.key.remoteJid, {
        react: { text: "üïê", key: msg.key },
      });

      // Comando de fechar grupo
      if (command === "fechar") {
        if (!isOwner) {
          await sock.sendMessage(msg.key.remoteJid, {
            text:
              "*Voc√™ n√£o tem permiss√£o para usar este comando.*\n\n" +
              getMessageEnd(),
          });
          return;
        }

        const botAdmin = await isBotAdmin(msg.key.remoteJid);
        if (!botAdmin) {
          await sock.sendMessage(msg.key.remoteJid, {
            text:
              "*N√£o posso fechar o grupo porque n√£o sou administrador.*\n\n" +
              getMessageEnd(),
          });
          await sock.sendMessage(msg.key.remoteJid, {
            react: { text: "‚ùå", key: msg.key }, // Rea√ß√£o de erro
          });
          return;
        }

        // Fecha o grupo
        await sock.groupSettingUpdate(msg.key.remoteJid, "announcement");
        await sock.sendMessage(msg.key.remoteJid, {
          text: "*O grupo foi fechado!* üîí\n\n" + getMessageEnd(),
        });
        return;
      }
    }
  });

  console.log("BOT LIGADO!");
}

function normalizeCommand(command) {
  return command.trim().toLowerCase();
}

// Fun√ß√£o para formatar o uptime
function formatUptime(ms) {
  const totalSeconds = Math.floor(ms / 1000);
  const days = Math.floor(totalSeconds / (3600 * 24));
  const hours = Math.floor((totalSeconds % (3600 * 24)) / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;

  return `${days} dias ${hours} horas ${minutes} minutos e ${seconds} segundos`;
}

async function getSimSimiResponse(message) {
  try {
    const response = await axios.post(SIMI_API_URL, {
      lc: "pt",
      text: message,
    });
    return response.data.contents;
  } catch (error) {
    throw new Error(
      `N√£o foi poss√≠vel obter uma resposta do SimSimi: ${error.message}`
    );
  }
}

function getMessageEnd() {
  return "„Éü‚òÖ *MagoBot¬†JS¬†1.3*¬†‚òÖÂΩ°";
}

startBot();
